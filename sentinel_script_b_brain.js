/**
 * ‚ö° SPARK_Labs Sentinel: Script B - The Brain (Logic Engine)
 * ==========================================================
 * VERSION: v1.0 (BETA)
 * TARGET:  Shelly Gen3 / Gen4
 * * DESCRIPTION:
 * The central state machine. It receives clean events from The Bridge (Script A),
 * manages the input buffer (pattern recognition), enforces security lockouts,
 * and updates the Virtual Interface (UI) in real-time.
 */

const CONFIG = {
  // üîå HARDWARE OUTPUT
  // The ID of the relay to toggle when unlocked (0 is standard for most Shellies).
  RELAY_ID: 0,
  
  // üõ°Ô∏è SECURITY PARAMETERS
  SECURITY: {
    MAX_FAILS: 3,        // Lock system after 3 wrong codes
    LOCKOUT_MS: 30000,   // Duration of lockout (30 Seconds)
    TIMEOUT_MS: 6000,    // Time between clicks before code resets (6 Seconds)
    MANUAL_WINDOW: 10000 // If door opens >10s after unlock, log as "Manual Entry"
  },

  // üì± VIRTUAL COMPONENT MAPPING
  // These IDs must match what was generated by Script C (Installer).
  // DO NOT CHANGE unless you manually altered the Components in the App.
  VC: {
    KEYPAD: 200,   
    STATUS: 200,    
    DOOR:   200,    
    TIME:   200,    
    VISUAL: 201,    
    USER:   201     
  },

  // üìù UI TEXT MAPPINGS
  // Defines what text appears on the "Status" component.
  STATUS: {
    ERROR:   "Error ",        // Displayed on wrong code (Mapped to ‚ö†Ô∏è)
    READY:   " System Ready", // Idle state (Mapped to üîí)
    ACTIVE:  "Input Active",  // Typing in progress (Mapped to ‚è∞)
    LOCKED:  "Locked Out",    // Security Lockout (Mapped to ‚õî)
    SUCCESS: "Success"        // Unlocked (Mapped to üëç)
  },

  // üìú HISTORY LOGGING KEYS
  LOG_KEYS: {
    MANUAL:  "Manual",
    LOCKOUT: "Lock out", 
    FAIL:    "Fail "     
  },

  // ========================================================================
  // üë• USER DATABASE (CONFIGURATION REQUIRED)
  // ========================================================================
  // INSTRUCTIONS:
  // 1. 'name': Internal ID (Keep short).
  // 2. 'slot': Must match the "User History" options in Script C exactly.
  // 3. 'mac': The LOWERCASE address of the user's specific button.
  // 4. 'pass': The sequence required to unlock.
  //    Options: "single_push", "double_push", "triple_push", "long_push"
  USERS: [
    { 
      name: "Dad",      
      slot: "User 1", 
      mac: "mac_address_user_1", 
      pass: ["double_push", "single_push", "double_push"] 
    },
    { 
      name: "MUM",      
      slot: "User 2", 
      mac: "mac_address_user_2", 
      pass: ["single_push", "double_push", "single_push"] 
    },
    { 
      name: "Kid1",  
      slot: "User 3", 
      mac: "mac_address_user_3", 
      pass: ["double_push", "double_push", "single_push"] 
    },
    { 
      name: "Kid2",    
      slot: "User 4", 
      mac: "mac_address_user_4", 
      pass: ["triple_push", "single_push", "single_push"] 
    },
    { 
      name: "Guest",  
      slot: "User 5", 
      mac: "mac_address_user_5", 
      pass: ["single_push", "single_push", "double_push"] 
    },
    
    // System Reserved - Do Not Edit
    { name: "Manual",   slot: "Manual", mac: "manual", pass: [] } 
  ],

  STORAGE_KEY: "access_hist", 
  DEBUG: true
};

// ========================================================================
// ‚öôÔ∏è STATE MACHINE & TIMERS
// ========================================================================
let STATE = {
  buffer: [],        // Stores the current sequence of clicks
  lastPress: 0,      // Timestamp of last activity
  doorOpen: false,   // Current state of physical door sensor
  fails: 0,          // Counter for failed attempts
  lockoutUntil: 0,   // Timestamp when lockout expires
  lastUnlockTime: 0  // Timestamp of last authorized unlock
};

let TIMERS = { reset: null, history: null, queue: null, lockout: null, input: null };

function log(msg) {
  if (CONFIG.DEBUG) console.log("[BRAIN] " + msg);
}

// ========================================================================
// 1. SERIAL RPC QUEUE
// ========================================================================
// Why this exists: Shelly RPC calls are asynchronous. If we try to update 
// 5 UI components simultaneously (Status, Visuals, Time, etc.), 
// the requests might fail or arrive out of order. 
// This queue forces them to execute one by one (FIFO).
let Queue = {
  _items: [],
  _busy: false,

  add: function(method, params) {
    this._items.push({ m: method, p: params });
    this.process();
  },

  process: function() {
    if (this._busy || this._items.length === 0) return;
    this._busy = true;
    let task = this._items.splice(0, 1)[0];
    Shelly.call(task.m, task.p, function() {
      Queue._busy = false;
      if (Queue._items.length > 0) Queue.process();
    });
  }
};

// ========================================================================
// 2. DASHBOARD & SMART TIME
// ========================================================================

/**
 * Formats timestamps into "Smart" strings.
 * e.g., "14:30 | T" (Today) or "14:30 | 25/11" (Date)
 */
function formatSmartTime(ts) {
  let date = new Date(ts);
  if (isNaN(date.getTime())) date = new Date(); 

  let now = new Date();
  let hh = ("0" + date.getHours()).slice(-2);
  let mm = ("0" + date.getMinutes()).slice(-2);
  let timeStr = hh + ":" + mm;
  
  let isToday = (now.getDate() === date.getDate() && now.getMonth() === date.getMonth());
  let isYesterday = ((now.getDate() - 1) === date.getDate() && now.getMonth() === date.getMonth());

  if (isToday) return timeStr + " | T";
  if (isYesterday) return timeStr + " | T-1";
  return timeStr + " | " + date.getDate() + "/" + (date.getMonth() + 1);
}

function updateUI(type, value) {
  if (type === "status") Queue.add("Enum.Set", { id: CONFIG.VC.STATUS, value: value });
  if (type === "visual") Queue.add("Text.Set", { id: CONFIG.VC.VISUAL, value: value });
  if (type === "door")   Queue.add("Boolean.Set", { id: CONFIG.VC.DOOR, value: !!value });
  
  if (type === "history") {
    // Sends 'value.slot' (User 1) to UI to allow installer consistency
    Queue.add("Enum.Set", { id: CONFIG.VC.USER, value: value.slot });
    Queue.add("Text.Set", { id: CONFIG.VC.TIME, value: formatSmartTime(value.date) });
  }
}

// ========================================================================
// 3. PERSISTENCE (KVS Storage)
// ========================================================================

function saveHistory(userObjOrString) {
  let now = Date.now(); 
  let internalName, uiSlot;

  // Handle Object (User) vs String (Fail/Lockout)
  if (typeof userObjOrString === 'object') {
    internalName = userObjOrString.name;
    uiSlot = userObjOrString.slot;
  } else {
    internalName = userObjOrString;
    uiSlot = userObjOrString; // For Fail/Lockout, slot is same as string
  }

  let record = { u: uiSlot, t: now }; 
  Script.storage.setItem(CONFIG.STORAGE_KEY, JSON.stringify(record));
  
  updateUI("history", { name: internalName, slot: uiSlot, date: now });
}

function loadHistory() {
  let data = Script.storage.getItem(CONFIG.STORAGE_KEY);
  if (data) {
    try {
      let rec = JSON.parse(data);
      updateUI("history", { name: rec.u, slot: rec.u, date: rec.t });
      log("History Restored: " + rec.u);
    } catch(e) { log("History Parse Error"); }
  } else {
    log("No History Found (First Run)");
  }
}

// ========================================================================
// 4. LOGIC ENGINE
// ========================================================================

/**
 * Resets the buffer and UI to the "Ready" state.
 * Called after timeouts, successful unlocks, or explicit resets.
 */
function reset(reason) {
  STATE.buffer = [];
  STATE.lastPress = 0;
  
  // Kill the input timer on reset
  if (TIMERS.input) { Timer.clear(TIMERS.input); TIMERS.input = null; }
  
  let statusStr = CONFIG.STATUS.READY; 
  
  if (STATE.fails >= CONFIG.SECURITY.MAX_FAILS && Date.now() < STATE.lockoutUntil) {
    statusStr = CONFIG.STATUS.LOCKED;
  }
  
  updateUI("status", statusStr);
  updateUI("visual", ""); 
  
  if (reason) log("Reset: " + reason);
}

function triggerUnlock(user) {
  log(">>> UNLOCK SUCCESS: " + user.name);
  STATE.fails = 0;
  STATE.lockoutUntil = 0;
  STATE.lastUnlockTime = Date.now();
  
  if (TIMERS.lockout) { Timer.clear(TIMERS.lockout); TIMERS.lockout = null; }
  if (TIMERS.input) { Timer.clear(TIMERS.input); TIMERS.input = null; }

  updateUI("status", CONFIG.STATUS.SUCCESS); 
  updateUI("visual", "‚úÖ‚úÖ‚úÖ‚úÖ‚úÖ");
  
  // ‚ö° HARDWARE ACTUATION
  Shelly.call("Switch.Set", { id: CONFIG.RELAY_ID, on: true });
  
  if (TIMERS.history) Timer.clear(TIMERS.history);
  TIMERS.history = Timer.set(1000, false, function() {
    saveHistory(user); // Pass full user object
    TIMERS.history = null;
  });
  
  if (TIMERS.reset) Timer.clear(TIMERS.reset);
  TIMERS.reset = Timer.set(4000, false, function() { 
    reset("Post-Unlock"); 
    TIMERS.reset = null;
  });
}

function processInput(source, pressType) {
  let now = Date.now();

  // Inactivity Timer: Auto-reset if user stops typing for 6 seconds
  if (TIMERS.input) Timer.clear(TIMERS.input);
  TIMERS.input = Timer.set(CONFIG.SECURITY.TIMEOUT_MS, false, function() {
      reset("Inactivity Auto-Reset");
  });

  // Check Lockout Status
  if (now < STATE.lockoutUntil) {
    updateUI("status", CONFIG.STATUS.LOCKED); 
    return;
  }

  // Safety buffer timeout (Should be covered by Inactivity Timer, but double check)
  if (STATE.buffer.length > 0 && (now - STATE.lastPress > CONFIG.SECURITY.TIMEOUT_MS)) {
    reset("Timeout Safety");
  }

  STATE.buffer.push(pressType);
  STATE.lastPress = now;
  updateUI("status", CONFIG.STATUS.ACTIVE);
  
  // Visual Feedback (e.g., "‚úÖ‚úÖ")
  let visuals = ""; 
  for(let k=0; k < STATE.buffer.length; k++) visuals += "‚úÖ"; 
  updateUI("visual", visuals);

  // PATTERN MATCHING
  let matchUser = null;
  let partialMatch = false;

  for (let i = 0; i < CONFIG.USERS.length; i++) {
    let u = CONFIG.USERS[i];
    if (u.name === "Manual") continue; 

    // Filter: User must be using THEIR registered button (or virtual keypad)
    if (source !== "virtual" && u.mac !== source) continue; 
    
    let isPath = true;
    for (let k = 0; k < STATE.buffer.length; k++) {
      if (u.pass[k] !== STATE.buffer[k]) isPath = false;
    }

    if (isPath) {
      if (STATE.buffer.length === u.pass.length) matchUser = u;
      else partialMatch = true;
    }
  }

  if (matchUser) {
    triggerUnlock(matchUser);
  } else if (!partialMatch) {
    // WRONG CODE LOGIC
    STATE.fails++;
    
    saveHistory(CONFIG.LOG_KEYS.FAIL);
    updateUI("status", CONFIG.STATUS.ERROR);
    updateUI("visual", visuals + "‚ùå");
    
    if (STATE.fails >= CONFIG.SECURITY.MAX_FAILS) {
      STATE.lockoutUntil = now + CONFIG.SECURITY.LOCKOUT_MS;
      updateUI("status", CONFIG.STATUS.LOCKED);
      saveHistory(CONFIG.LOG_KEYS.LOCKOUT);
      
      if (TIMERS.lockout) Timer.clear(TIMERS.lockout);
      TIMERS.lockout = Timer.set(CONFIG.SECURITY.LOCKOUT_MS, false, function() {
          log("Lockout Expired");
          STATE.fails = 0;
          STATE.lockoutUntil = 0;
          updateUI("status", CONFIG.STATUS.READY);
          TIMERS.lockout = null;
      });
    }
    
    if (TIMERS.reset) Timer.clear(TIMERS.reset);
    TIMERS.reset = Timer.set(1000, false, function() { 
      reset("Wrong Code"); 
      TIMERS.reset = null;
    });
  }
}

// ========================================================================
// 5. EVENT HANDLER (THE LISTENER)
// ========================================================================

Shelly.addEventHandler(function(event) {
  if (!event || !event.info) return;

  // A. BRIDGE EVENT (From Script A)
  if (event.info.event === "custom_ble_bridge") {
    let d = event.info.data;
    
    // 1. Button Press
    if (d.type && d.type !== "door_state") {
      processInput(d.mac, d.type); 
    }
    
    // 2. Door Sensor
    if (d.type === "door_state") {
      let isOpen = d.state;
      STATE.doorOpen = isOpen;
      updateUI("door", isOpen); 
      
      if (isOpen) {
        // Manual Entry Check: If door opens without a recent app unlock
        if ((Date.now() - STATE.lastUnlockTime) > CONFIG.SECURITY.MANUAL_WINDOW) {
          log("Manual Entry Detected");
          if (TIMERS.history) Timer.clear(TIMERS.history);
          TIMERS.history = Timer.set(500, false, function() { 
            saveHistory(CONFIG.LOG_KEYS.MANUAL); 
            TIMERS.history = null;
          });
          STATE.lastUnlockTime = Date.now(); 
        }
      }
    }
  }

  // B. VIRTUAL KEYPAD (For Debugging/Testing without Button)
  if (event.info.component === "button:" + CONFIG.VC.KEYPAD) {
    if (event.info.event) {
      processInput("virtual", event.info.event);
    }
  }
});

function init() {
  console.log("--- ‚ö°Ô∏èSPARK Sentinel Brain V1 Running ---");
  loadHistory();
  updateUI("status", CONFIG.STATUS.READY);
}

init();